# Аналіз проєкту

### Дослідження існуючих альтернатив, вільних в мережі Інтернет

Першим знайденим прикладом можна вважати роботу користувача Github з юзернеймом [langroodi](https://github.com/langroodi). Його метою було створити репозиторій AUTOSAR Adaptive з нуля, і тому на цьому шляху йому довелось розробити інтерфейс для моніторів застосунку.
У цілому код виконаний гарно, можна дослідити, що він відповідає стандарту Adaptive-AUTOSAR. Код містить наступні переваги:

 * Безпечна перевірка наявності подій
 * Використання const посилань скрізь, де це можливо
 * Коректне використання просторів імен
 * Гарне коментування коду
 * Використання перерахувань (*enum*)

Проте цей код має і декілька недоліків:
  * *monitor.h* використовується не тільки для визначення властивостей та методів
  * Використовується динамічна пам'ять, що виділяється оператором *new*, що може впливати на безпеку застосунку

[langroodi Adaptive AUTOSAR implementation](https://github.com/langroodi/Adaptive-AUTOSAR/blob/master/src/ara/diag/monitor.h)

Другий приклад створення інтерфейсу *ara::diag::Monitor* можна вважати роботу [weicanqd](https://github.com/weicanqd). Користувач створив репозиторій з метою навчання, де фокусувався на розробці UDS\_Transport модулів.
Можна помітити, що його робота не дороблена, але навіть в цій розробці є свої плюси та мінуси, які можна примітити для нашої розробки. Код містить наступні переваги:

 * Код коректніше маніпулює просторами імен, що спрощує його читабельність та переносимість
 * Не використовується виділення динамічної пам'яті оператором *new*
 * *.h* файл використовується лише для оголошення властивостивостей та методів

Головними недоліками є:
 * Відсутність реалізації в окремому файлі *.cpp*

[weicanqd learning Adaptive platfom standards](https://github.com/weicanqd/Adaptive\_AUTOSAR_ETH/blob/master/diag_uds_transport/ara/diag/monitor.h)

### Набір функцій майбутнього проєкту (за специфікацією Adaptive-AUTOSAR)

**[SWS_DM_01740]** Початковий стан увімкнення зі зворотним викликом сповіщення для вимкнених станів увімкнення.

Деталі:
Якщо викликається *ara::diag::Monitor::Offer* і *ara::diag::Monitor* має зареєстрований зворотний виклик *initMonitor*,
а увімкнена умова, призначена для цієї події, перебуває у стані *kDisabled*,
то DM(Diagnostic management) викликає зареєстрований метод сповіщення *ara::diag::Monitor::Monitor::initMonitor* з параметром *ara::diag::InitMonitorReason*,
встановленим у *kDisabled.c*

**[SWS_DM_00562]** Ініціалізація монітору під час очищення.

Деталі:
Якщо асоційоване DTC (Diagnostic Trouble Code згідно до ISO 14229-1), що належить до поточного шляху моніторингу,
було фактично очищене, то DM повинен викликати зареєстрований метод сповіщення *ara::diag::Monitor::Monitor::initMonitor*
з параметром *ara::diag::InitMonitorReason*, встановленим у *kClear*.

**[SWS_DM_00563]** Ініціалізація моніторингу під час перезапуску робочого циклу.

Деталі:
Якщо діагностична подія була (пере)запущена викликом методу *ara::diag::OperationCycle::RestartOperationCycle*,
то DM викликає зареєстрований метод сповіщення *ara::diag::Monitor::Monitor::initMonitor* 
з параметром *ara::diag::InitMonitorReason*, що має значення *kRestart*.

**[SWS_DM_01094]** Ініціалізація моніторингу під час повторного увімкнення умови та виконання налаштування *ControlDTCSetting*.

Деталі:
Якщо умова дозволу, зіставлена з діагностичною подією, була змінена на виконану,
і таким чином були виконані всі пов'язані з нею умови дозволу події,
а встановлення DTC знову дозволено за допомогою сервісного запиту UDS *ControlDTCSetting* - *0x85*, встановленого на On (див. ISO 14229-1[1]),
то DM викликає зареєстрований метод сповіщення *ara::diag::Monitor::Monitor::initMonitor* з параметром *ara::diag::InitMonitorReason*,
встановленим у *kReenabled*.

**[SWS_DM_01095]** Відстажування ініціалізації, якщо ввімкнення не відбувається або параметр *ControlDTCSetting* вимкнений (OFF).

Деталі:
Якщо умова дозволу, зіставлена з діагностичною подією, була змінена на невиконану 
або встановлення DTC вимкнено за допомогою сервісного запиту UDS *ControlDTCSetting* - *0x85*, 
встановленого на Off (див. ISO 14229-1[1]),
то DM викликає зареєстрований метод сповіщення *ara::diag::Monitor::Monitor::initMonitor* з параметром *ara::diag::InitMonitorReason*,
встановленим у *kDisabled*.

**[SWS_DM_00965]** Кешування результатів моніторингу.

Деталі:
Якщо викликано функцію *ara::diag::Monitor::ReportMonitorAction*,
а DM наразі не готовий обробити кваліфікацію події, про яку повідомляється,
то DM повинен закешувати принаймні один кваліфікований результат **PASSED** та кваліфікований результат **FAILED** 
і обробити кваліфікований результат **FAILED/PASSED**, коли з'єднання з демоном (daemon) буде повторно встановлено.
